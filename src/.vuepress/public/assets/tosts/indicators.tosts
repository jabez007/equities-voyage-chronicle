###
#
###

###
# Trend Advisor Market Phases
# [URL]https://usethinkscript.com/threads/market-phases-indicator-for-thinkorswim.1025[/URL]
# Credits
#  - Chuck Dukas for creating the Market Phases system
#  - the author of VolumeTrendLabels whose study was use to create this indicator.
#
### 

#Ensure you set the correct aggregation period to then chart, this helps calculate the correct volume and price action.
input vPeriod = AggregationPeriod.DAY; #hint vPeriod: Enter the chart time you use here. Required to properly caluclate volume and price strength.

def O = open(period = vPeriod);
def H = high(period = vPeriod);
def C = close(period = vPeriod);
def L = low(period = vPeriod);
def V = volume(period = vPeriod);

def SV = V * (H - C) / (H - L);
def BV = V * (C - L) / (H - L);


####
# below determines if volume supports the move, adds conviction
####

def buyerVol = high > high[1] and low > low[1] and BV*1.05 > SV;
AddLabel(yes, " Buyer Vol Strong ", if buyerVol then Color.GREEN else color.black);

def sellerVol = high < high[1] and low < low[1] and SV*1.05 > BV;
AddLabel(yes, " Seller Vol Strong ", if sellerVol then Color.MAGENTA else color.black);


####
# below determines if price supports the move
####

def strongPrice = high > high[1] and high[1] > high[2] and low > low[1] and low[1] > low[2];
AddLabel(yes, " Price Strong ", if strongPrice then Color.GREEN else color.black);

def weakPrice = high < high[1] and high[1] < high[2] and low < low[1] and low[1] < low[2];
AddLabel(yes, " Price Weak ", if weakPrice then Color.MAGENTA else color.black);


####
# Moving Averages used to determine Bullish or Bearish
####

input price = FundamentalType.CLOSE; #hint price: which value to use for the moving averages
def src = Fundamental(FundamentalType = price, Period = vPeriod);

####

input fastAvgLength = 50;
input fastAvgType   = AverageType.SIMPLE;

plot fastMA = MovingAverage(fastAvgType, src, fastAvgLength);
fastMA.SetDefaultColor(Color.DARK_ORANGE);
fastMA.SetLineWeight(3);

def Fast_MA_Height = fastMA - fastMA[1];
def Fast_MA_Angle  = Atan(Fast_MA_Height) * 180 / Double.Pi;

####

input slowAvgLength = 200;
input slowAvgType   = AverageType.SIMPLE;

plot slowMA = MovingAverage(slowAvgType, src, slowAvgLength);
slowMA.SetDefaultColor(Color.YELLOW);
slowMA.SetLineWeight(5);

def Slow_MA_Height = slowMA - slowMA[1];
def Slow_MA_Angle  = Atan(Slow_MA_Height) * 180 / Double.Pi;

####
# Bullish criteria define below
####

# Define criteria for Bullish Phase : close > 50 SMA, close > 200 SMA, 50 SMA > 200 SMA
# Higher highs and higher lows
# Buy the dips, volume expands on breakouts, new highs
# Accelerating momentum and volume
def bullphase = (
    fastMA > slowMA
    #&&
    #((Fast_MA_Angle > 0) and (Slow_MA_Angle > 0))
    &&
    src > fastMA 
    &&
    src > slowMA
);

# Define criteria for Accumulation Phase : close > 50 SMA, close > 200 SMA, 50 SMA < 200 SMA
# Begin to see new 60 period HH
def accphase = (
    fastMA < slowMA
    #&&
    #((Fast_MA_Angle > 0) and (Slow_MA_Angle >= 0))
    &&
    src > fastMA
    &&
    src > slowMA
);

# Define criteria for Recovery Phase : close > 50 SMA, close < 200 SMA, 50 SMA < 200 SMA

def recphase = (
    fastMA < slowMA
    #&&
    #((Fast_MA_Angle >= 0) and (Slow_MA_Angle < 0))
    &&
    src < slowMA
    &&
    src > fastMA
);


####
# Bearish Criteria define below
####

# Define criteria for Bearish Phase : close < 50 SMA, close < 200 SMA, 50 SMA < 200 SMA

def bearphase = (
    fastMA < slowMA
    #&&
    #((Fast_MA_Angle < 0) and (Slow_MA_Angle < 0))
    &&
    src < fastMA
    &&
    src < slowMA
);

# Define criteria for Distribution Phase : close < 50 SMA, close < 200 SMA, 50 SMA > 200 SMA

def distphase = (
    fastMA > slowMA
    #&&
    #((Fast_MA_Angle < 0) and (Slow_MA_Angle <= 0))
    &&
    src < fastMA
    &&
    src < slowMA
);

# Define criteria for Warning Phase : close < 50 SMA, close > 200 SMA, 50 SMA > 200 SMA

def warnphase = (
    fastMA > slowMA
    #&&
    #((Fast_MA_Angle <= 0) and (Slow_MA_Angle > 0))
    &&
    src > slowMA
    &&
    src < fastMA
);

####
#plot buphase = bullphase is true;
#plot acphase = accphase is true;
#plot rephase = recphase is true;
####
#plot bephase = bearphase is true;
#plot dphase = distphase is true;
#plot wphase = warnphase is true;
####

assignPriceColor(if bullphase then Color.GREEN else if bearphase then Color.RED else if (accphase or distphase or recphase or warnphase) then Color.ORANGE else Color.GRAY);

############################################
#### END of Trend Advisor Market Phases ####
############################################

###
# Bull Market Support Band
# [URL]https://www.tradingview.com/script/uSBR7cFa-Bull-Market-Support-Band-20w-SMA-21w-EMA/[/URL]
###

input bullPeriod      = AggregationPeriod.WEEK;
input bull_MA1_Length = 20;
input bull_MA1_Type   = AverageType.SIMPLE;
input bull_MA2_Length = 21;
input bull_MA2_Type   = AverageType.EXPONENTIAL;

plot bull_MA1 = MovingAverage(bull_MA1_Type, fundamental(price, period = bullPeriod), bull_MA1_Length);
bull_MA1.DefineColor("UpTrend", Color.GREEN);
bull_MA1.DefineColor("DownTrend", Color.RED);
def bull_MA1_Trend = compoundValue(1, 
    if (bull_MA1 > bull_MA1[1]) then 1 else if (bull_MA1 < bull_MA1[1]) then -1 else bull_MA1_Trend[1],
    if (bull_MA1 > bull_MA1[1]) then 1 else -1);
bull_MA1.AssignValueColor(if (bull_MA1_Trend == 1) then bull_MA1.Color("UpTrend") else if (bull_MA1_Trend == -1) then bull_MA1.Color("DownTrend") else Color.ORANGE);

plot bull_MA2 = MovingAverage(bull_MA2_Type, fundamental(price, period = bullPeriod), bull_MA2_Length);
bull_MA2.DefineColor("UpTrend", Color.GREEN);
bull_MA2.DefineColor("DownTrend", Color.RED);
def bull_MA2_Trend = compoundValue(1,
    if (bull_MA2 > bull_MA2[1]) then 1 else if (bull_MA2 < bull_MA2[1]) then -1 else bull_MA2_Trend[1],
    if (bull_MA2 > bull_MA2[1]) then 1 else -1);
bull_MA2.AssignValueColor(if (bull_MA2_Trend == 1) then bull_MA2.Color("UpTrend") else if (bull_MA2_Trend == -1) then bull_MA2.Color("DownTrend") else Color.ORANGE);

addCloud(
    bull_MA1,
    bull_MA2,
    Color.ORANGE,
    Color.ORANGE
);

#########################################
#### END of Bull Market Support Band ####
#########################################

####
#// This source code is subject to the terms of the Mozilla Public License 2.0 a
#// Â© btc_charlie / @TheParagonGrp
#indicator('[@btc_charlie] Trader XO Macro Trend Scanner', overlay=true)
# -- Converted by Sam4Cok@Samer800    - 01/2024
# updated MTF option by Sam4Cok@Samer800    - 01/2024
####

input highlightBackground = yes;
input TrendAvgType        = AverageType.EXPONENTIAL;
input TrendFastLength     = 12;#, title='Fast EMA')
input TrendSlowLength     = 25;#, title='Slow EMA')
input showBothMovAvg      = yes;#(title='Show Both EMAs', defval=true)
input ConsolidatedLength  = 25;#, title='Consolidated EMA')

def na = Double.NaN;

#// Define the MAs
def v_fastMA = MovingAverage(TrendAvgType, src, TrendFastLength);
def v_slowMA = MovingAverage(TrendAvgType, src, TrendSlowLength);
def v_biasMA = MovingAverage(TrendAvgType, src, ConsolidatedLength);

#// Color the MAs
def TrendColor = if v_fastMA > v_slowMA then  1 else
                 if v_fastMA < v_slowMA then -1 else 0;

#// Plot the MAs
plot ConsMA        = if showBothMovAvg then na       else v_biasMA; # 'Consolidated EMA'
plot TrendFastLine = if showBothMovAvg then v_fastMA else na;#, title='Fast EMA', color=emaColor)
plot TrendSlowLine = if showBothMovAvg then v_slowMA else na;#, title='Slow EMA', color=emaColor)
ConsMA.SetLineWeight(2);
ConsMA.AssignValueColor(if TrendColor > 0 then Color.GREEN else
                        if TrendColor < 0 then Color.RED else Color.GRAY);
TrendFastLine.AssignValueColor(if TrendColor > 0 then Color.GREEN else
                               if TrendColor < 0 then Color.RED else Color.GRAY);
TrendSlowLine.AssignValueColor(if TrendColor > 0 then Color.GREEN else
                               if TrendColor < 0 then Color.RED else Color.GRAY);
#// Colour the bars
def buy = v_fastMA > v_slowMA;
def sell = v_fastMA < v_slowMA;

#// Variables
def countBuy;
def countSell;

if buy {
    countBuy  = countBuy[1] + 1;
    countSell = 0;
 } else if sell {
    countSell = countSell[1] + 1;
    countBuy  = 0;
    } else {
    countBuy = countBuy[1];
    countSell = countSell[1];
}

def buysignal = countBuy < 2 and countBuy > 0 and countSell < 1 and buy and !buy[1];
def sellsignal = countSell > 0 and countSell < 2 and countBuy < 1 and sell and !sell[1];

#// Plot Bull/Bear

AddChartBubble(buysignal, low, "Bull", Color.GREEN, no);
AddChartBubble(sellsignal, high, "Bear", Color.RED);

def bull = countBuy > 1 and highlightBackground;
def bear = countSell > 1 and highlightBackground;
def pos = Double.POSITIVE_INFINITY;
def neg = Double.NEGATIVE_INFINITY;

AddCloud(if (bull and (bullphase or accphase  or recphase))  then pos else na, neg, Color.DARK_GREEN);
AddCloud(if (bear and (bearphase or distphase or warnphase)) then pos else na, neg, Color.DARK_RED);

###########################
### END of Macro Trend ####
###########################

####
# Smoothed Heiken Ashi
####

input HA_Avg_Length = 20;
input HA_Avg_Type   = AverageType.EXPONENTIAL;

def MA_HA_Close = MovingAverage(HA_Avg_Type, HA_Close, HA_Avg_Length);
def MA_HA_Open  = MovingAverage(HA_Avg_Type, HA_Open,  HA_Avg_Length);
def MA_HA_High  = MovingAverage(HA_Avg_Type, HA_High,  HA_Avg_Length);
def MA_HA_Low   = MovingAverage(HA_Avg_Type, HA_Low,   HA_Avg_Length);

####

#def HA_Close_MA = (MA_HA_Open + MA_HA_High + MA_HA_Low + MA_HA_Close) / 4.0;
#def HA_Open_MA  = if IsNaN(HA_Open_MA[1]) then (MA_HA_Open + MA_HA_Close) / 2.0 else (HA_Open_MA[1] + HA_Close_MA[1]) / 2.0;
#def HA_High_MA  = Max(MA_HA_High, Max(HA_Open_MA, HA_Close_MA));
#def HA_Low_MA   = Min(MA_HA_Low,  Min(HA_Open_MA, HA_Close_MA));

#Red Candlesticks -----------------------------------------------------------------|

def MA_HA_Open_fall  = if MA_HA_Open >  MA_HA_Close then MA_HA_Open  else double.nan;
def MA_HA_High_fall  = if MA_HA_Open >= MA_HA_Close then MA_HA_High  else double.nan;
def MA_HA_Low_fall   = if MA_HA_Open >= MA_HA_Close then MA_HA_Low   else double.nan;
def MA_HA_Close_fall = if MA_HA_Open >= MA_HA_Close then MA_HA_Close else double.nan;

# royalBlue = createColor(65, 105, 225)
AddChart(growColor = Color.plum, fallColor = createColor(65, 105, 225), neutralColor = Color.current, high = MA_HA_High_fall, low = MA_HA_Low_fall, open = MA_HA_Open_fall, close = MA_HA_Close_fall , type = ChartType.CANDLE);

#Green Candlesticks ---------------------------------------------------------------|

def MA_HA_Open_rise  = if MA_HA_Open <  MA_HA_Close then MA_HA_Close else double.nan;
def MA_HA_High_rise  = if MA_HA_Open <= MA_HA_Close then MA_HA_High  else double.nan;
def MA_HA_Low_rise   = if MA_HA_Open <= MA_HA_Close then MA_HA_Low   else double.nan;
def MA_HA_Close_rise = if MA_HA_Open <= MA_HA_Close then MA_HA_Open  else double.nan;

# royalBlue = createColor(65, 105, 225)
AddChart(growColor = createColor(65, 105, 225), fallColor = Color.plum, neutralColor = Color.current, high = MA_HA_High_rise, low = MA_HA_Low_rise, open = MA_HA_Open_rise, close = MA_HA_Close_rise, type = ChartType.CANDLE);


#############################################################
###   Determine a flat market
#############################################################

input TradeInFlatRange = yes;
input BarsForFlatRange = 15;
input BarsReqToStayInRange = 13;

def HH = Highest(high[1], BarsForFlatRange);
def LL = Lowest(low[1], BarsForFlatRange);
def maxH = Highest(HH, BarsReqToStayInRange);
def maxL = Lowest(LL, BarsReqToStayInRange);
def HHn = if maxH == maxH[1] or maxL == maxL then maxH else HHn[1];
def LLn = if maxH == maxH[1] or maxL == maxL then maxL else LLn[1];
def Bh = if high <= HHn and HHn == HHn[1] then HHn else Double.NaN;
def Bl = if low >= LLn and LLn == LLn[1] then LLn else Double.NaN;
def CountH = if IsNaN(Bh) or IsNaN(Bl) then 2 else CountH[1] + 1;
def CountL = if IsNaN(Bh) or IsNaN(Bl) then 2 else CountL[1] + 1;
def ExpH = if BarNumber() == 1 then Double.NaN else
    if CountH[-BarsReqToStayInRange] >= BarsReqToStayInRange then HHn[-BarsReqToStayInRange] else
    if high <= ExpH[1] then ExpH[1] else Double.NaN;
def ExpL = if BarNumber() == 1 then Double.NaN else
    if CountL[-BarsReqToStayInRange] >= BarsReqToStayInRange then LLn[-BarsReqToStayInRange] else
    if low >= ExpL[1] then ExpL[1] else Double.NaN;

def BoxHigh = if !isnan(expL) and !isnan(ExpH) then ExpH else double.nan;
def BoxLow = if !isnan(expL) and !isnan(ExpH) then ExpL else double.nan;

addcloud(BoxHigh, BoxLow, color.gray, color.gray, yes);

def Flat = if (!isNan(BoxHigh[1]) and !isNan(BoxLow[1])) and !TradeInFlatRange then 1 else 0;


####
# The conditions below are for possible entries when price pulls back
# Inspired by the Bravo9
####

input pbAvgLength = 9; #hint pbAvgLength: The length of the fast moving average to use for pullback entries.
input pbAvgType = AverageType.SIMPLE; #hint pbAvgType: The fast moving average type to use for pullback entries.
input pbDisplace = 0; #hint pbDisplace: The displacement of the fast moving average to use for pullback entries.

plot pbMA = MovingAverage(pbAvgType, data = HA_Open[-pbDisplace], length = pbAvgLength);
pbMA.SetDefaultColor(Color.LIME);
pbMA.SetLineWeight(2);

input ROCLength = 11;
assert(ROCLength > 0, "'ROC Length' must be positive: " + ROCLength);

def ROCPrice = HA_Close;
def ROC = if ROCPrice[ROCLength] != 0 then (ROCPrice / ROCPrice[ROCLength] - 1) * 100 else 0;

####

input RSI_Length   = 14;
input RSI_Avg_Type = AverageType.WILDERS;

def NetChgAvg = MovingAverage(RSI_Avg_Type, fundamental(price, period = vPeriod) - fundamental(price, period = vPeriod)[1], RSI_Length);
def TotChgAvg = MovingAverage(RSI_Avg_Type, AbsValue(fundamental(price, period = vPeriod) - fundamental(price, period = vPeriod)[1]), RSI_Length);
def ChgRatio  = if TotChgAvg != 0 then NetChgAvg / TotChgAvg else 0;
def RSI       = 50 * (ChgRatio + 1);

input RSI_Lookback = 3;

####

input MFLength   = 14;
input MFILength  = 1;
input MFIAvgType = AverageType.SIMPLE;

def MoneyFlowIndex = MovingAverage(
    MFIAvgType,
    moneyflow(H, C, L, V, MFLength),
    MFILength
);

input avgMFILength  = 3;
input avgMFIAvgType = AverageType.WILDERS;

def avgMFI = MovingAverage(avgMFIAvgType, MoneyFlowIndex, avgMFILength);

####

def bullishpb = ( # L < pbsma && O > pbsma;
    #Min(O, C) >= pbsma # full candle close above
    #&&
    !Flat
    &&
    (HA_Close > HA_Open and (HA_Close - HA_Open) > (HA_Close[1] - HA_Open[1]))
    &&
    (HA_Close > pbMA) #and (HA_Close - pbMA) > (HA_Close[1] - pbMA[1]))
    &&
    (40 < RSI and IsAscending(RSI, RSI_Lookback))
    #&&
    #((MA_HA_Close - MA_HA_Open) > (MA_HA_Close[1] - MA_HA_Open[1]))
    #&&
    #(bullHAClose > bullHAOpen and (bullHAClose - bullHAOpen) > (bullHAClose[1] - bullHAOpen[1]))
    #&&
    #(MA_Bull_HA_Close > MA_Bull_HA_Open) #and (bullSHAClose - bullSHAOpen) > (bullSHAClose[1] - bullSHAOpen[1]))
    #&&
    #ROC > 0
    
    #&&
    #avgMFI > avgMFI[1]
);
def bullpb = (
    if (bullphase) then (
        bullishpb
    ) else if (accphase) then (
        bullishpb
    ) else if (recphase) then (
        bullishpb
    ) else (
        (!bearphase and !distphase and !warnphase)
        &&
        bullishpb
    )
);

def bearishpb = ( # H > pbsma && O < pbsma;
    #Max(O, C) <= pbsma # full candle close below
    #&&
    !Flat
    &&
    (HA_Open > HA_Close and (HA_Open - HA_Close) > (HA_Open[1] - HA_Close[1]))
    &&
    (pbMA > HA_Close) #and (pbMA - HA_Close) > (pbMA[1] - HA_Close[1]))
    &&
    (60 > RSI and IsDescending(RSI, RSI_Lookback))
    #&&
    #((MA_HA_Open - MA_HA_Close) > (MA_HA_Open[1] - MA_HA_Close[1]))
    #&&
    #(bullHAOpen > bullHAClose and (bullHAOpen - bullHAClose) > (bullHAOpen[1] - bullHAClose[1]))
    #&&
    #(MA_Bull_HA_Open > MA_Bull_HA_Close) #and (bullSHAOpen - bullSHAClose) > (bullSHAOpen[1] - bullSHAClose[1]))
    #&&
    #ROC < 0
    #&
    #avgMFI < avgMFI[1]
);
def bearpb = (
    if (bearphase) then (
        bearishpb
    ) else if (distphase) then (
        bearishpb
    ) else if (warnphase) then (
        bearishpb
    ) else (
        (!bullphase and !accphase and !recphase)
        &&
        bearishpb
    )
);

####
# The conditions below are for stop losses
# Inspired by the Accurate Swing Trading System
####

input useStops = yes;

def UT9X = compoundValue(1, if (C > C[4]) then UT9X[1] + 1 else 0, 0);
plot UT9 = (
    if (UT9X == 1 && !isNaN(UT9X[-8]) && UT9X[-8] == 9) then UT9X
    else if (UT9X == 2 && !isNaN(UT9X[-7]) && UT9X[-7] == 9) then UT9X
    else if (UT9X == 3 && !isNaN(UT9X[-6]) && UT9X[-6] == 9) then UT9X
    else if (UT9X == 4 && !isNaN(UT9X[-5]) && UT9X[-5] == 9) then UT9X
    else if (UT9X == 5 && !isNaN(UT9X[-4]) && UT9X[-4] == 9) then UT9X
    else if (UT9X == 6 && !isNaN(UT9X[-3]) && UT9X[-3] == 9) then UT9X
    else if (UT9X == 7 && !isNaN(UT9X[-2]) && UT9X[-2] == 9) then UT9X
    else if (UT9X == 8 && !isNaN(UT9X[-1]) && UT9X[-1] == 9) then UT9X
    else if (UT9X >= 9) then UT9X
    else Double.NaN
);
UT9.SetPaintingStrategy(PaintingStrategy.Values_Above);
UT9.AssignValueColor(if UT9 < 9 then Color.CYAN else Color.MAGENTA);

def DT9X = compoundValue(1, if (C < C[4]) then DT9X[1] + 1 else 0, 0);
plot DT9 = (
    if (DT9X == 1 && !isNaN(DT9X[-8]) && DT9X[-8] == 9) then DT9X
    else if (DT9X == 2 && !isNaN(DT9X[-7]) && DT9X[-7] == 9) then DT9X
    else if (DT9X == 3 && !isNaN(DT9X[-6]) && DT9X[-6] == 9) then DT9X
    else if (DT9X == 4 && !isNaN(DT9X[-5]) && DT9X[-5] == 9) then DT9X
    else if (DT9X == 5 && !isNaN(DT9X[-4]) && DT9X[-4] == 9) then DT9X
    else if (DT9X == 6 && !isNaN(DT9X[-3]) && DT9X[-3] == 9) then DT9X
    else if (DT9X == 7 && !isNaN(DT9X[-2]) && DT9X[-2] == 9) then DT9X
    else if (DT9X == 8 && !isNaN(DT9X[-1]) && DT9X[-1] == 9) then DT9X
    else if (DT9X >= 9) then DT9X
    else Double.NaN
);
DT9.SetPaintingStrategy(PaintingStrategy.Values_Below);
DT9.AssignValueColor(if DT9 < 9 then Color.MAGENTA else Color.CYAN);

####

def bullstp = (
    pbMA > HA_Close
);

def bearstp = (
    HA_Close > pbMA
);

####

input trailType = {default modified, heikinashi, unmodified};
input ATRPeriod = 5;
input ATRFactor = 2.9;
input ATRAverageType = AverageType.WILDERS;

Assert(ATRFactor > 0, "'atr factor' must be positive: " + ATRFactor);

def HiLo = Min(H - L, 1.5 * Average(H - L, ATRPeriod));
def HRef = if L <= H[1]
    then H - C[1]
    else (H - C[1]) - 0.5 * (L - H[1]);
def LRef = if H >= L[1]
    then C[1] - L
    else (C[1] - L) - 0.5 * (L[1] - H);

def trueRange;
switch (trailType) {
    case modified:
        trueRange = Max(HiLo, Max(HRef, LRef));
    case heikinashi:
        trueRange = TrueRange(HA_High, HA_Close, HA_Low);
    case unmodified:
        trueRange = TrueRange(H, C, L);
}
def loss = ATRFactor * MovingAverage(ATRAverageType, trueRange, ATRPeriod);


#######################################
##  Maintain the position of trades
#######################################

def CurrentPosition;  # holds whether flat = 0 long = 1 short = -1
def trail;

if ((BarNumber() == 1) OR isNaN(CurrentPosition[1])) {
    CurrentPosition = 0;
    trail = Double.NaN;
} else {
    if (CurrentPosition[1] == 0) {               # FLAT
        if (bullpb) {
            CurrentPosition = 1;
            trail = C - loss;
        } else if (bearpb){
            CurrentPosition = -1;
            trail = C + loss;
        } else {
            CurrentPosition = CurrentPosition[1];
            trail = trail[1];
        }
    } else if (CurrentPosition[1] == 1) {        # LONG
        if (bearpb){
            CurrentPosition = -1;
            trail = C + loss;
        } else if (useStops and (bullstp or C < trail[1])){
            CurrentPosition = 0;
            trail = Double.NaN;
        } else {
            CurrentPosition = CurrentPosition[1];
            trail = Max(trail[1], C - loss);
        }
    } else if (CurrentPosition[1] == -1) {       # SHORT
        if (bullpb){
            CurrentPosition = 1;
            trail = C - loss;
        } else if (useStops and (bearstp or C > trail[1])){
            CurrentPosition = 0;
            trail = Double.NaN;
        } else {
            CurrentPosition = CurrentPosition[1];
            trail = Min(trail[1], C + loss);
        }
    } else {
        CurrentPosition = CurrentPosition[1];
        trail = trail[1];
    }
}

def isLong  = if CurrentPosition == 1 then 1 else 0;
def isShort = if CurrentPosition == -1 then 1 else 0;
def isFlat  = if CurrentPosition == 0 then 1 else 0;

plot TrailingStop = trail;
TrailingStop.SetPaintingStrategy(PaintingStrategy.POINTS);
TrailingStop.AssignValueColor(if isLong then Color.MAGENTA else if isShort then Color.CYAN else Color.GRAY);

input useAlerts = no;

# If not already long and get a BuySignal
Plot BuySig = if (!isLong[1] and bullpb) then 1 else 0;
BuySig.AssignValueColor(color.CYAN);
BuySig.SetPaintingStrategy(PaintingStrategy.BOOLEAN_ARROW_UP);
BuySig.SetLineWeight(5);

Alert(BuySig and useAlerts, "Buy Signal", Alert.bar, sound.Ding);
Alert(BuySig and useAlerts, "Buy Signal", Alert.bar, sound.Ding);

# If not already short and get a SellSignal
Plot SellSig = if (!isShort[1] and bearpb) then 1 else 0;
SellSig.AssignValueColor(color.MAGENTA);
SellSig.SetPaintingStrategy(PaintingStrategy.BOOLEAN_ARROW_DOWN);
SellSig.SetLineWeight(5);

Alert(SellSig and useAlerts, "Sell Signal", Alert.bar, sound.Ding);
Alert(SellSig and useAlerts, "Sell Signal", Alert.bar, sound.Ding);

# If long and get a BuyStop
Plot BuyStpSig = if (useStops and (bullstp or C < trail[1]) and isLong[1]) then 1 else 0;
BuyStpSig.AssignValueColor(color.LIGHT_GRAY);
BuyStpSig.SetPaintingStrategy(PaintingStrategy.BOOLEAN_ARROW_DOWN);
BuyStpSig.SetLineWeight(3);

# If short and get a SellStop
Plot SellStpSig = if (useStops and (bearstp or C > trail[1]) and isShort[1]) then 1 else 0;
SellStpSig.AssignValueColor(color.LIGHT_GRAY);
SellStpSig.SetPaintingStrategy(PaintingStrategy.BOOLEAN_ARROW_UP);
SellStpSig.SetLineWeight(3);


####
# Below adds labels to the chart to identify what phase the underlying is in
####

AddLabel(bullphase, " Bull Phase " , if bullphase is true then Color.GREEN else Color.BLACK);

AddLabel(accphase, " Accumation Phase ", if accphase is true then Color.LIGHT_GREEN else Color.BLACK);

AddLabel(recphase, " Recovery Phase ", if recphase is true then Color.LIGHT_ORANGE else Color.BLACK);

AddLabel(warnphase, " Warning Phase ", if warnphase is true then Color.ORANGE else Color.BLACK);

AddLabel(distphase, " Distribution Phase ", if distphase is true then Color.LIGHT_RED else Color.BLACK);

AddLabel(bearphase, " Bear Phase ", if bearphase is true then Color.RED else Color.BLACK);


#### spacer
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
#### end spacer code

#######################################
##  Orders
#######################################

def isOrder = if CurrentPosition == CurrentPosition[1] then 0 else 1; # Position changed so it's a new order

# If there is an order to open, then the price is the next day's open
def orderPrice = if (isOrder and (bullpb or bearpb)) then O[-1] else orderPrice[1];


#######################################
##  Price and Profit
#######################################

def profitLoss;

if (!isOrder or orderPrice[1] == 0){
    profitLoss = 0;
# If there is an order to close, 
} else if ((isOrder and isLong[1]) and (SellSig or BuyStpSig)){
    profitLoss = (if (isNaN(O[-1])) then C else O[-1])  - orderPrice[1]; # then the price is the next day's open
} else if ((isOrder and isShort[1]) and (BuySig or SellStpSig)) {
    profitLoss = orderPrice[1] - (if (isNaN(O[-1])) then C else O[-1]); # then the price is the next day's open
} else {
    profitLoss = 0;
}

# Total Profit or Loss
def profitLossSum = compoundValue(1, if isNaN(isOrder)  or barnumber()==1 then 0 else if isOrder then profitLossSum[1] + profitLoss else profitLossSum[1], 0);

# How many trades won or lost
def profitWinners = compoundValue(1, if isNaN(profitWinners[1]) or barnumber()==1 then 0 else if isOrder and profitLoss > 0 then profitWinners[1] + 1 else profitWinners[1], 0);
def profitLosers = compoundValue(1, if isNaN(profitLosers[1])  or barnumber()==1 then 0 else if isOrder and profitLoss < 0 then profitLosers[1] + 1 else profitLosers[1], 0);
def profitPush = compoundValue(1, if isNaN(profitPush[1])  or barnumber()==1 then 0 else if isOrder and profitLoss == 0 then profitPush[1] + 1 else profitPush[1], 0);

def orderCount = (profitWinners + profitLosers + profitPush) - 1;

# Current Open Trade Profit or Loss
def TradePL = If isLong then Round(((close - orderprice)/TickSize())*TickValue()) else if isShort then Round(((orderPrice - close)/TickSize())*TickValue()) else 0;

# Convert to actual dollars based on Tick Value for bubbles
def dollarProfitLoss = if orderPRice[1]==0 or isNaN(orderPrice[1]) then 0 else round((profitLoss/Ticksize())*Tickvalue());

# Closed Orders dollar P/L
def dollarPLSum = round((profitLossSum/Ticksize())*Tickvalue());

# Split profits or losses by long and short trades
def profitLong = compoundValue(1, if isNan(profitLong[1])  or barnumber()==1 then 0 else if isOrder and isLong[1] then profitLong[1]+dollarProfitLoss else profitLong[1],0);
def profitShort = compoundValue(1, if isNan(profitShort[1])  or barnumber()==1 then 0 else if isOrder and isShort[1] then profitShort[1]+dollarProfitLoss else profitShort[1],0);
def countLong = compoundValue(1, if isNaN(countLong[1])  or barnumber()==1 then 0 else if isOrder and isLong[1] then countLong[1]+1 else countLong[1],0);
def countShort = compoundValue(1, if isNaN(countShort[1])  or barnumber()==1 then 0 else if isOrder and isShort[1] then countShort[1]+1 else countShort[1],0);

# What was the biggest winning and losing trade
def biggestWin = compoundValue(1, if isNaN(biggestWin[1]) or barnumber()==1 then 0 else if isOrder and (dollarProfitLoss > 0) and (dollarProfitLoss > biggestWin[1]) then dollarProfitLoss else biggestWin[1], 0);
def biggestLoss = compoundValue(1, if isNaN(biggestLoss[1]) or barnumber()==1 then 0 else if isOrder and (dollarProfitLoss < 0) and (dollarProfitLoss < biggestLoss[1]) then dollarProfitLoss else biggestLoss[1], 0);

# What percent were winners
def PCTWin = round((profitWinners/orderCount)*100,2);

# Average trade
def avgTrade = round((dollarPLSum/orderCount),2);


#######################################
##  Create Labels
#######################################

input showLabels = yes;

AddLabel(showLabels, GetSymbol()+" Tick Size: "+TickSize()+" Value: "+TickValue()+" HODL: "+AsDollars(C-First(O)), color.white);
AddLabel(showLabels, "Closed Orders: " + orderCount + " P/L: " + AsDollars(dollarPLSum), if dollarPLSum > 0 then Color.GREEN else if dollarPLSum< 0 then Color.RED else Color.GRAY);
AddLabel(if !IsNan(orderPrice) and showLabels then 1 else 0, "Closed+Open P/L: "+ AsDollars(TradePL+dollarPLSum), if ((TradePL+dollarPLSum) > 0) then color.green else if ((TradePL+dollarPLSum) < 0) then color.red else color.gray);

AddLabel(showLabels, "Avg per Trade: "+ AsDollars(avgTrade), if avgTrade > 0 then Color.Green else if avgTrade < 0 then Color.RED else Color.GRAY);
AddLabel(showLabels, "Winners: "+ PCTWin +"%",if PCTWin > 50 then color.green else if PCTWin > 40 then color.yellow else color.gray);

AddLabel(showLabels, "MaxUp: "+ AsDollars(biggestWin) +" MaxDown: "+AsDollars(biggestLoss), color.white);
AddLabel(showLabels, "Long Profit: " +AsDollars(profitLong), if profitLong > 0 then color.green else if profitLong < 0 then color.red else color.gray);
AddLabel(showLabels, "Short Profit: " +AsDollars(profitShort), if profitShort > 0 then color.green else if profitShort < 0 then color.red else color.gray);
AddLabel(if !IsNan(CurrentPosition) and showLabels then 1 else 0, "Open: "+ (If isLong then "Bought" else "Sold") + " @ "+orderPrice, color.white);
AddLabel(if !IsNan(orderPrice) and showLabels then 1 else 0, "Open Trade P/L: "+ AsDollars(TradePL), if (TradePL > 0) then color.green else if (TradePl < 0) then color.red else color.gray);


#######################################
##  Chart Bubbles for Profit/Loss
#######################################

input showBubbles = yes;

AddChartBubble(showBubbles and isOrder and isLong[1], low, "$"+dollarProfitLoss, if dollarProfitLoss == 0 then Color.LIGHT_GRAY else if dollarProfitLoss > 0 then Color.GREEN else color.Red, 0);
AddChartBubble(showBubbles and isOrder and isShort[1], high,  "$"+dollarProfitLoss, if dollarProfitLoss == 0 then Color.LIGHT_GRAY else if dollarProfitLoss > 0 then Color.GREEN else color.Red, 1);
