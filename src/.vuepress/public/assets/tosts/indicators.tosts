#hint: Trend Advisor Market Phases Swing Trader;

###
# Credits
#  - Chuck Dukas for creating the Market Phases system
#  - the author of VolumeTrendLabels whose study was use to create this indicator.
#
### 

#Ensure you set the correct aggregation period to then chart, this helps calculate the correct volume and price action.
input vPeriod = AggregationPeriod.DAY; #hint vPeriod: Enter the chart time you use here. Required to properly caluclate volume and price strength.

def O = open(period = vPeriod);
def H = high(period = vPeriod);
def C = close(period = vPeriod);
def L = low(period = vPeriod);
def V = volume(period = vPeriod);

def SV = V * (H - C) / (H - L);
def BV = V * (C - L) / (H - L);


####
# below determines if volume supports the move, adds conviction
####

def buyerVol = high > high[1] and low > low[1] and BV*1.05 > SV;
AddLabel(yes, " Buyer Vol Strong ", if buyerVol then Color.GREEN else color.black);

def sellerVol = high < high[1] and low < low[1] and SV*1.05 > BV;
AddLabel(yes, " Seller Vol Strong ", if sellerVol then Color.MAGENTA else color.black);


####
# below determines if price supports the move
####

def strongPrice = high > high[1] and high[1] > high[2] and low > low[1] and low[1] > low[2];
AddLabel(yes, " Price Strong ", if strongPrice then Color.GREEN else color.black);

def weakPrice = high < high[1] and high[1] < high[2] and low < low[1] and low[1] < low[2];
AddLabel(yes, " Price Weak ", if weakPrice then Color.MAGENTA else color.black);


####
# Moving Averages used to determine Bullish or Bearish
####

input price = FundamentalType.CLOSE; #hint price: which value to use for the moving averages

input fastavgType = AverageType.EXPONENTIAL;
input fastavg = 50;

input slowavgType = AverageType.SIMPLE;
input slowavg = 200;

plot fastsma = MovingAverage(fastavgType, fundamental(price, period = vPeriod), fastavg);
fastsma.SetDefaultColor(Color.DARK_ORANGE);
fastsma.SetLineWeight(3);

def fastsmaheight = fastsma - fastsma[1];
def fastsmaAngle = Atan(fastsmaheight) * 180 / Double.Pi;

plot slowsma = MovingAverage(slowavgType, fundamental(price, period = vPeriod), slowavg);
slowsma.SetDefaultColor(Color.YELLOW);
slowsma.SetLineWeight(5);

def slowsmaheight = slowsma - slowsma[1];
def slowsmaAngle = Atan(slowsmaheight) * 180 / Double.Pi;


####
# Bullish criteria define below
####

# Define criteria for Bullish Phase : close > 50 SMA, close > 200 SMA, 50 SMA > 200 SMA

def bullphase = (
    fastsma > slowsma
    &&
    (fastsmaAngle > 0) && (slowsmaAngle > 0)
    && 
    fundamental(price, period = vPeriod) > fastsma 
    &&
    fundamental(price, period = vPeriod) > slowsma
);

# Define criteria for Accumulation Phase : close > 50 SMA, close > 200 SMA, 50 SMA < 200 SMA

def accphase = (
    fastsma < slowsma
    &&
    (fastsmaAngle > 0) && (slowsmaAngle >= 0)
    &&
    fundamental(price, period = vPeriod) > fastsma
    &&
    fundamental(price, period = vPeriod) > slowsma
);

# Define criteria for Recovery Phase : close > 50 SMA, close < 200 SMA, 50 SMA < 200 SMA

def recphase = (
    fastsma < slowsma
    &&
    (fastsmaAngle >= 0) && (slowsmaAngle < 0)
    &&
    fundamental(price, period = vPeriod) < slowsma
    &&
    fundamental(price, period = vPeriod) > fastsma
);


####
# Bearish Criteria define below
####

# Define criteria for Bearish Phase : close < 50 SMA, close < 200 SMA, 50 SMA < 200 SMA

def bearphase = (
    fastsma < slowsma
    &&
    (fastsmaAngle < 0) && (slowsmaAngle < 0)
    &&
    fundamental(price, period = vPeriod) < fastsma
    &&
    fundamental(price, period = vPeriod) < slowsma
);

# Define criteria for Distribution Phase : close < 50 SMA, close < 200 SMA, 50 SMA > 200 SMA

def distphase = (
    fastsma > slowsma
    &&
    (fastsmaAngle < 0) && (slowsmaAngle <= 0)
    &&
    fundamental(price, period = vPeriod) < fastsma
    &&
    fundamental(price, period = vPeriod) < slowsma
);

# Define criteria for Warning Phase : close < 50 SMA, close > 200 SMA, 50 SMA > 200 SMA

def warnphase = (
    fastsma > slowsma
    &&
    (fastsmaAngle <= 0) && (slowsmaAngle > 0)
    &&
    fundamental(price, period = vPeriod) > slowsma
    &&
    fundamental(price, period = vPeriod) < fastsma
);

####
#plot buphase = bullphase is true;
#plot acphase = accphase is true;
#plot rephase = recphase is true;
####
#plot bephase = bearphase is true;
#plot dphase = distphase is true;
#plot wphase = warnphase is true;
####

input bPeriod = AggregationPeriod.WEEK;
input bSource = FundamentalType.CLOSE;
input bullSMALength = 20;
input bullEMALength = 21;

def bullSMA = Average(fundamental(bSource, period = bPeriod), bullSMALength);
def bullEMA = ExpAverage(fundamental(bSource, period = bPeriod), bullEMALength);

addCloud(
    bullSMA,
    bullEMA,
    color.RED,
    color.GREEN
);

####
# Smoothed Heiken Ashi
####

input shaPeriod = 20;
input haMovingAverageType = AverageType.EXPONENTIAL;

def openMA  = compoundValue(1, MovingAverage(haMovingAverageType, open(period = vPeriod),  shaPeriod), open(period = vPeriod));
def closeMA = compoundValue(1, MovingAverage(haMovingAverageType, close(period = vPeriod), shaPeriod), close(period = vPeriod));
def highMA  = compoundValue(1, MovingAverage(haMovingAverageType, high(period = vPeriod),  shaPeriod), high(period = vPeriod));
def lowMA   = compoundValue(1, MovingAverage(haMovingAverageType, low(period = vPeriod),   shaPeriod), low(period = vPeriod));

input hideCandles = no;
hidePricePlot(hideCandles);

def shaOpen;
def shaClose;

input haCandleSmoothing = {default Valcu, Vervoort};

switch(haCandleSmoothing) {
case Valcu:
    shaOpen = CompoundValue(1, ((shaOpen[1] + (openMA[1] + highMA[1] + lowMA[1] + closeMA[1]) /4.0) / 2.0), open(period = vPeriod));
    shaClose = ((OpenMA + HighMA + LowMA + CloseMA) / 4.0) ;

case Vervoort:
    shaOpen = CompoundValue(1, ((shaOpen[1] + (openMA[1] + highMA[1] + lowMA[1] + closeMA[1]) /4.0) / 2.0), open(period = vPeriod));
    shaClose = ((((OpenMA + HighMA + LowMA + CloseMA) / 4.0) + shaOpen + Max(HighMA, shaOpen) + Min(LowMA, shaOpen)) / 4.0);
}

#plot hao = shaOpen + 0;
#hao.hide();

### Wicks and Shadows

def shaLow = min(lowMA, shaOpen);
def shaHigh = max(highMA, shaOpen);

#Red Candlesticks -----------------------------------------------------------------|

def shaOpen_fall  = if shaOpen >  shaClose then shaOpen  else double.nan;
def shaHigh_fall  = if shaOpen >= shaClose then shaHigh  else double.nan;
def shaLow_fall   = if shaOpen >= shaClose then shaLow   else double.nan;
def shaClose_fall = if shaOpen >= shaClose then shaClose else double.nan;

# royalBlue = createColor(65, 105, 225)
AddChart(growColor = Color.plum, fallColor = createColor(65, 105, 225), neutralColor = Color.current, high = shaHigh_fall, low = shaLow_fall, open = shaOpen_fall, close = shaClose_fall , type = ChartType.CANDLE);

#Green Candlesticks ---------------------------------------------------------------|

def shaOpen_rise  = if shaOpen <  shaClose then shaClose else double.nan;
def shaHigh_rise  = if shaOpen <= shaClose then shaHigh  else double.nan;
def shaLow_rise   = if shaOpen <= shaClose then shaLow   else double.nan;
def shaClose_rise = if shaOpen <= shaClose then shaOpen  else double.nan;

# royalBlue = createColor(65, 105, 225)
AddChart(growColor = createColor(65, 105, 225), fallColor = Color.plum, neutralColor = Color.current, high = shaHigh_rise, low = shaLow_rise, open = shaOpen_rise, close = shaClose_rise, type = ChartType.CANDLE);


#############################################################
###   Determine a flat market
#############################################################

input TradeInFlatRange = yes;
input BarsForFlatRange = 15;
input BarsReqToStayInRange = 13;

def HH = Highest(high[1], BarsForFlatRange);
def LL = Lowest(low[1], BarsForFlatRange);
def maxH = Highest(HH, BarsReqToStayInRange);
def maxL = Lowest(LL, BarsReqToStayInRange);
def HHn = if maxH == maxH[1] or maxL == maxL then maxH else HHn[1];
def LLn = if maxH == maxH[1] or maxL == maxL then maxL else LLn[1];
def Bh = if high <= HHn and HHn == HHn[1] then HHn else Double.NaN;
def Bl = if low >= LLn and LLn == LLn[1] then LLn else Double.NaN;
def CountH = if IsNaN(Bh) or IsNaN(Bl) then 2 else CountH[1] + 1;
def CountL = if IsNaN(Bh) or IsNaN(Bl) then 2 else CountL[1] + 1;
def ExpH = if BarNumber() == 1 then Double.NaN else
    if CountH[-BarsReqToStayInRange] >= BarsReqToStayInRange then HHn[-BarsReqToStayInRange] else
    if high <= ExpH[1] then ExpH[1] else Double.NaN;
def ExpL = if BarNumber() == 1 then Double.NaN else
    if CountL[-BarsReqToStayInRange] >= BarsReqToStayInRange then LLn[-BarsReqToStayInRange] else
    if low >= ExpL[1] then ExpL[1] else Double.NaN;

def BoxHigh = if !isnan(expL) and !isnan(ExpH) then ExpH else double.nan;
def BoxLow = if !isnan(expL) and !isnan(ExpH) then ExpL else double.nan;

addcloud(BoxHigh, BoxLow, color.gray, color.gray);

def Flat = if (!isNan(BoxHigh[1]) and !isNan(BoxLow[1])) and !TradeInFlatRange then 1 else 0;

####

def haClose = (open(period = vPeriod) + high(period = vPeriod) + low(period = vPeriod) + close(period = vPeriod)) / 4;
def haOpen = compoundValue(1, (haOpen[1] + haClose[1]) / 2, (open(period = vPeriod)[1] + close(period = vPeriod)[1]) / 2);
def haHigh = Max(Max(high(period = vPeriod), haOpen), haClose);
def haLow = Min(Min(low(period = vPeriod), haOpen), haClose);

####
# The conditions below are for possible entries when price pulls back
# Inspired by the Bravo9
####

input pbavgType = AverageType.SIMPLE; #hint pbavgType: The fast moving average type to use for pullback entries.
input pbavg = 9; #hint pbavg: The length of the fast moving average to use for pullback entries.
input pbdisplace = 0; #hint pbdisplace: The displacement of the fast moving average to use for pullback entries.

plot pbsma = MovingAverage(pbavgType, data = fundamental(price, period = vPeriod)[-pbdisplace], length = pbavg);
pbsma.SetDefaultColor(Color.LIME);
pbsma.SetLineWeight(2);

input MACDFastLength = 12;
input MACDSlowLength = 26;
input MACDLength = 9;
input MACDAverageType = AverageType.EXPONENTIAL;

def MACDline = MovingAverage(MACDAverageType, fundamental(price, period = vPeriod), MACDFastLength) - MovingAverage(MACDAverageType, fundamental(price, period = vPeriod), MACDSlowLength);
def MACDsig = MovingAverage(MACDAverageType, MACDLine, MACDLength);

def MACDhist = MACDline - MACDsig;

input MACDLookback = 5;

input RSILength = 14;
input RSIAverageType = AverageType.WILDERS;

def NetChgAvg = MovingAverage(RSIAverageType, fundamental(price, period = vPeriod) - fundamental(price, period = vPeriod)[1], RSILength);
def TotChgAvg = MovingAverage(RSIAverageType, AbsValue(fundamental(price, period = vPeriod) - fundamental(price, period = vPeriod)[1]), RSILength);
def ChgRatio = if TotChgAvg != 0 then NetChgAvg / TotChgAvg else 0;
def RSI = 50 * (ChgRatio + 1);

input avgRSILength = 3;
input avgRSIAverageType = AverageType.WILDERS;

def avgRSI = MovingAverage(avgRSIAverageType, RSI, avgRSILength);

input OBVLength = 7;
input OBVSignalLength = 10;
input OBVAverageType = AverageType.EXPONENTIAL;

def obv = reference OnBalanceVolume();

def OBVM = MovingAverage(OBVAverageType, obv, OBVLength);
def OBVSignal = MovingAverage(OBVAverageType, OBVM, OBVSignalLength);

input ADXLength = 14;
input ADXAverageType = AverageType.WILDERS;

def ADX = DMI(ADXLength, ADXAverageType).ADX;

input ADXTrendThreshold = 20;

####

def bullishpb = ( # low(period = vPeriod) < pbsma && open(period = vPeriod) > pbsma;
    #Min(open(period = vPeriod), close(period = vPeriod)) >= pbsma # full candle close above
    #&&
    !Flat
    &&
    (shaClose > shaOpen and (shaClose - shaOpen) > (shaClose[1] - shaOpen[1]))
    &&
    (haClose > haOpen and (haClose - haOpen) > (haClose[1] - haOpen[1]))
    &&
    ((39 < RSI && RSI < 63) and avgRSI > avgRSI[1]) # bullish but not overbought and rising RSI
    #&&
    #(MACDhist > 0 and Lowest(MACDhist, MACDLookback) < 0 and MACDLine > MACDLine[1]) # recent positive cross on the MACD and rising
    #&&
    #OBVM > OBVM[1] # On Balance Volume is rising
);
def bullpb = (
    if (bullphase) then (
        bullishpb
    ) else if (accphase) then (
        bullishpb
    ) else if (recphase) then (
        bullishpb
    ) else (
        (!bearphase and !distphase and !warnphase)
        &&
        bullishpb
    )
);


def bearishpb = ( # high(period = vPeriod) > pbsma && open(period = vPeriod) < pbsma;
    #Max(open(period = vPeriod), close(period = vPeriod)) <= pbsma # full candle close below
    #&&
    !Flat
    &&
    (shaOpen > shaClose and (shaOpen - shaClose) > (shaOpen[1] - shaClose[1]))
    &&
    (haOpen > haClose and (haOpen - haClose) > (haOpen[1] - haClose[1]))
    &&
    ((36 < RSI && RSI < 60) and avgRSI < avgRSI[1]) # bearish but not oversold and falling RSI
    #&&
    #(MACDhist < 0 and Highest(MACDhist, MACDLookback) > 0 and MACDLine < MACDLine[1]) # recent negative cross on the MACD and falling
    #&&
    #OBVM < OBVM[1] # On Balance Volume is falling
);
def bearpb = (
    if (bearphase) then (
        bearishpb
    ) else if (distphase) then (
        bearishpb
    ) else if (warnphase) then (
        bearishpb
    ) else (
        (!bullphase and !accphase and !recphase)
        &&
        bearishpb
    )
);

####
# The conditions below are for stop losses
# Inspired by the Accurate Swing Trading System
####

input useStops = yes;

input stplength = 3;
input stpdisplace = -1;

def stpDailyHigh = Highest(high(period = vPeriod)[-stpdisplace], stplength);
def stpDailyLow = Lowest(low(period = vPeriod)[-stpdisplace], stplength);

def UT9X = compoundValue(1, if (close(period = vPeriod) > close(period = vPeriod)[4]) then UT9X[1] + 1 else 0, 0);
plot UT9 = (
    if (UT9X == 1 && !isNaN(UT9X[-8]) && UT9X[-8] == 9) then UT9X
    else if (UT9X == 2 && !isNaN(UT9X[-7]) && UT9X[-7] == 9) then UT9X
    else if (UT9X == 3 && !isNaN(UT9X[-6]) && UT9X[-6] == 9) then UT9X
    else if (UT9X == 4 && !isNaN(UT9X[-5]) && UT9X[-5] == 9) then UT9X
    else if (UT9X == 5 && !isNaN(UT9X[-4]) && UT9X[-4] == 9) then UT9X
    else if (UT9X == 6 && !isNaN(UT9X[-3]) && UT9X[-3] == 9) then UT9X
    else if (UT9X == 7 && !isNaN(UT9X[-2]) && UT9X[-2] == 9) then UT9X
    else if (UT9X == 8 && !isNaN(UT9X[-1]) && UT9X[-1] == 9) then UT9X
    else if (UT9X >= 9) then UT9X
    else Double.NaN
);
UT9.SetPaintingStrategy(PaintingStrategy.Values_Above);
UT9.AssignValueColor(if UT9 < 9 then Color.CYAN else Color.MAGENTA);

def DT9X = compoundValue(1, if (close(period = vPeriod) < close(period = vPeriod)[4]) then DT9X[1] + 1 else 0, 0);
plot DT9 = (
    if (DT9X == 1 && !isNaN(DT9X[-8]) && DT9X[-8] == 9) then DT9X
    else if (DT9X == 2 && !isNaN(DT9X[-7]) && DT9X[-7] == 9) then DT9X
    else if (DT9X == 3 && !isNaN(DT9X[-6]) && DT9X[-6] == 9) then DT9X
    else if (DT9X == 4 && !isNaN(DT9X[-5]) && DT9X[-5] == 9) then DT9X
    else if (DT9X == 5 && !isNaN(DT9X[-4]) && DT9X[-4] == 9) then DT9X
    else if (DT9X == 6 && !isNaN(DT9X[-3]) && DT9X[-3] == 9) then DT9X
    else if (DT9X == 7 && !isNaN(DT9X[-2]) && DT9X[-2] == 9) then DT9X
    else if (DT9X == 8 && !isNaN(DT9X[-1]) && DT9X[-1] == 9) then DT9X
    else if (DT9X >= 9) then DT9X
    else Double.NaN
);
DT9.SetPaintingStrategy(PaintingStrategy.Values_Below);
DT9.AssignValueColor(if DT9 < 9 then Color.MAGENTA else Color.CYAN);

####

def bullstp = if !useStops then 0 else (
    0
);

def bearstp = if !useStops then 0 else (
    0
);

####

input trailType = {default modified, unmodified};
input ATRPeriod = 5;
input ATRFactor = 2.9;
input ATRAverageType = AverageType.WILDERS;

Assert(ATRFactor > 0, "'atr factor' must be positive: " + ATRFactor);

def HiLo = Min(high(period = vPeriod) - low(period = vPeriod), 1.5 * Average(high(period = vPeriod) - low(period = vPeriod), ATRPeriod));
def HRef = if low(period = vPeriod) <= high(period = vPeriod)[1]
    then high(period = vPeriod) - close(period = vPeriod)[1]
    else (high(period = vPeriod) - close(period = vPeriod)[1]) - 0.5 * (low(period = vPeriod) - high(period = vPeriod)[1]);
def LRef = if high(period = vPeriod) >= low(period = vPeriod)[1]
    then close(period = vPeriod)[1] - low(period = vPeriod)
    else (close(period = vPeriod)[1] - low(period = vPeriod)) - 0.5 * (low(period = vPeriod)[1] - high(period = vPeriod));

def trueRange;
switch (trailType) {
    case modified:
        trueRange = Max(HiLo, Max(HRef, LRef));
    case unmodified:
        trueRange = TrueRange(high(period = vPeriod), close(period = vPeriod), low(period = vPeriod));
}
def loss = ATRFactor * MovingAverage(ATRAverageType, trueRange, ATRPeriod);


#######################################
##  Maintain the position of trades
#######################################

def CurrentPosition;  # holds whether flat = 0 long = 1 short = -1
def trail;

if ((BarNumber() == 1) OR isNaN(CurrentPosition[1])) {
    CurrentPosition = 0;
    trail = Double.NaN;
} else {
    if (CurrentPosition[1] == 0) {               # FLAT
        if (bullpb) {
            CurrentPosition = 1;
            trail = close(period = vPeriod) - loss;
        } else if (bearpb){
            CurrentPosition = -1;
            trail = close(period = vPeriod) + loss;
        } else {
            CurrentPosition = CurrentPosition[1];
            trail = trail[1];
        }
    } else if (CurrentPosition[1] == 1) {        # LONG
        if (bearpb){
            CurrentPosition = -1;
            trail = close(period = vPeriod) + loss;
        } else if (bullstp or close(period = vPeriod) <= trail[1]){
            CurrentPosition = 0;
            trail = Double.NaN;
        } else {
            CurrentPosition = CurrentPosition[1];
            trail = Max(trail[1], close(period = vPeriod) - loss);
        }
    } else if (CurrentPosition[1] == -1) {       # SHORT
        if (bullpb){
            CurrentPosition = 1;
            trail = close(period = vPeriod) - loss;
        } else if (bearstp or close(period = vPeriod) >= trail[1]){
            CurrentPosition = 0;
            trail = Double.NaN;
        } else {
            CurrentPosition = CurrentPosition[1];
            trail = Min(trail[1], close(period = vPeriod) + loss);
        }
    } else {
        CurrentPosition = CurrentPosition[1];
        trail = trail[1];
    }
}

def isLong  = if CurrentPosition == 1 then 1 else 0;
def isShort = if CurrentPosition == -1 then 1 else 0;
def isFlat  = if CurrentPosition == 0 then 1 else 0;

plot TrailingStop = trail;
TrailingStop.SetPaintingStrategy(PaintingStrategy.POINTS);
TrailingStop.AssignValueColor(if isLong then Color.MAGENTA else if isShort then Color.CYAN else Color.GRAY);

input useAlerts = no;

# If not already long and get a BuySignal
Plot BuySig = if (!isLong[1] and bullpb) then 1 else 0;
BuySig.AssignValueColor(color.CYAN);
BuySig.SetPaintingStrategy(PaintingStrategy.BOOLEAN_ARROW_UP);
BuySig.SetLineWeight(5);

Alert(BuySig and useAlerts, "Buy Signal", Alert.bar, sound.Ding);
Alert(BuySig and useAlerts, "Buy Signal", Alert.bar, sound.Ding);

# If not already short and get a SellSignal
Plot SellSig = if (!isShort[1] and bearpb) then 1 else 0;
SellSig.AssignValueColor(color.MAGENTA);
SellSig.SetPaintingStrategy(PaintingStrategy.BOOLEAN_ARROW_DOWN);
SellSig.SetLineWeight(5);

Alert(SellSig and useAlerts, "Sell Signal", Alert.bar, sound.Ding);
Alert(SellSig and useAlerts, "Sell Signal", Alert.bar, sound.Ding);

# If long and get a BuyStop
Plot BuyStpSig = if ((bullstp or close(period = vPeriod) <= trail[1]) and isLong[1]) then 1 else 0;
BuyStpSig.AssignValueColor(color.LIGHT_GRAY);
BuyStpSig.SetPaintingStrategy(PaintingStrategy.BOOLEAN_ARROW_DOWN);
BuyStpSig.SetLineWeight(3);

# If short and get a SellStop
Plot SellStpSig = if ((bearstp or close(period = vPeriod) >= trail[1]) and isShort[1]) then 1 else 0;
SellStpSig.AssignValueColor(color.LIGHT_GRAY);
SellStpSig.SetPaintingStrategy(PaintingStrategy.BOOLEAN_ARROW_UP);
SellStpSig.SetLineWeight(3);


####
# Below adds labels to the chart to identify what phase the underlying is in
####

AddLabel(bullphase, " Bull Phase " , if bullphase is true then Color.GREEN else Color.BLACK);

AddLabel(accphase, " Accumation Phase ", if accphase is true then Color.LIGHT_GREEN else Color.BLACK);

AddLabel(recphase, " Recovery Phase ", if recphase is true then Color.LIGHT_ORANGE else Color.BLACK);

AddLabel(warnphase, " Warning Phase ", if warnphase is true then Color.ORANGE else Color.BLACK);

AddLabel(distphase, " Distribution Phase ", if distphase is true then Color.LIGHT_RED else Color.BLACK);

AddLabel(bearphase, " Bear Phase ", if bearphase is true then Color.RED else Color.BLACK);


#### spacer
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
addlabel(yes, "            ", color.BLACK);
#### end spacer code

#######################################
##  Orders
#######################################

def isOrder = if CurrentPosition == CurrentPosition[1] then 0 else 1; # Position changed so it's a new order

# If there is an order to open, then the price is the next day's open
def orderPrice = if (isOrder and (bullpb or bearpb)) then open(period = vPeriod)[-1] else orderPrice[1];


#######################################
##  Price and Profit
#######################################

def profitLoss;

if (!isOrder or orderPrice[1] == 0){
    profitLoss = 0;
# If there is an order to close, 
} else if ((isOrder and isLong[1]) and (SellSig or BuyStpSig)){
    profitLoss = (if (isNaN(open(period = vPeriod)[-1])) then close(period = vPeriod) else open(period = vPeriod)[-1])  - orderPrice[1]; # then the price is the next day's open
} else if ((isOrder and isShort[1]) and (BuySig or SellStpSig)) {
    profitLoss = orderPrice[1] - (if (isNaN(open(period = vPeriod)[-1])) then close(period = vPeriod) else open(period = vPeriod)[-1]); # then the price is the next day's open
} else {
    profitLoss = 0;
}

# Total Profit or Loss
def profitLossSum = compoundValue(1, if isNaN(isOrder)  or barnumber()==1 then 0 else if isOrder then profitLossSum[1] + profitLoss else profitLossSum[1], 0);

# How many trades won or lost
def profitWinners = compoundValue(1, if isNaN(profitWinners[1]) or barnumber()==1 then 0 else if isOrder and profitLoss > 0 then profitWinners[1] + 1 else profitWinners[1], 0);
def profitLosers = compoundValue(1, if isNaN(profitLosers[1])  or barnumber()==1 then 0 else if isOrder and profitLoss < 0 then profitLosers[1] + 1 else profitLosers[1], 0);
def profitPush = compoundValue(1, if isNaN(profitPush[1])  or barnumber()==1 then 0 else if isOrder and profitLoss == 0 then profitPush[1] + 1 else profitPush[1], 0);

def orderCount = (profitWinners + profitLosers + profitPush) - 1;

# Current Open Trade Profit or Loss
def TradePL = If isLong then Round(((close - orderprice)/TickSize())*TickValue()) else if isShort then Round(((orderPrice - close)/TickSize())*TickValue()) else 0;

# Convert to actual dollars based on Tick Value for bubbles
def dollarProfitLoss = if orderPRice[1]==0 or isNaN(orderPrice[1]) then 0 else round((profitLoss/Ticksize())*Tickvalue());

# Closed Orders dollar P/L
def dollarPLSum = round((profitLossSum/Ticksize())*Tickvalue());

# Split profits or losses by long and short trades
def profitLong = compoundValue(1, if isNan(profitLong[1])  or barnumber()==1 then 0 else if isOrder and isLong[1] then profitLong[1]+dollarProfitLoss else profitLong[1],0);
def profitShort = compoundValue(1, if isNan(profitShort[1])  or barnumber()==1 then 0 else if isOrder and isShort[1] then profitShort[1]+dollarProfitLoss else profitShort[1],0);
def countLong = compoundValue(1, if isNaN(countLong[1])  or barnumber()==1 then 0 else if isOrder and isLong[1] then countLong[1]+1 else countLong[1],0);
def countShort = compoundValue(1, if isNaN(countShort[1])  or barnumber()==1 then 0 else if isOrder and isShort[1] then countShort[1]+1 else countShort[1],0);

# What was the biggest winning and losing trade
def biggestWin = compoundValue(1, if isNaN(biggestWin[1]) or barnumber()==1 then 0 else if isOrder and (dollarProfitLoss > 0) and (dollarProfitLoss > biggestWin[1]) then dollarProfitLoss else biggestWin[1], 0);
def biggestLoss = compoundValue(1, if isNaN(biggestLoss[1]) or barnumber()==1 then 0 else if isOrder and (dollarProfitLoss < 0) and (dollarProfitLoss < biggestLoss[1]) then dollarProfitLoss else biggestLoss[1], 0);

# What percent were winners
def PCTWin = round((profitWinners/orderCount)*100,2);

# Average trade
def avgTrade = round((dollarPLSum/orderCount),2);


#######################################
##  Create Labels
#######################################

input showLabels = yes;

AddLabel(showLabels, GetSymbol()+" Tick Size: "+TickSize()+" Value: "+TickValue()+" HODL: "+AsDollars(close(period = vPeriod)-First(open(period = vPeriod))), color.white);
AddLabel(showLabels, "Closed Orders: " + orderCount + " P/L: " + AsDollars(dollarPLSum), if dollarPLSum > 0 then Color.GREEN else if dollarPLSum< 0 then Color.RED else Color.GRAY);
AddLabel(if !IsNan(orderPrice) and showLabels then 1 else 0, "Closed+Open P/L: "+ AsDollars(TradePL+dollarPLSum), if ((TradePL+dollarPLSum) > 0) then color.green else if ((TradePL+dollarPLSum) < 0) then color.red else color.gray);

AddLabel(showLabels, "Avg per Trade: "+ AsDollars(avgTrade), if avgTrade > 0 then Color.Green else if avgTrade < 0 then Color.RED else Color.GRAY);
AddLabel(showLabels, "Winners: "+ PCTWin +"%",if PCTWin > 50 then color.green else if PCTWin > 40 then color.yellow else color.gray);

AddLabel(showLabels, "MaxUp: "+ AsDollars(biggestWin) +" MaxDown: "+AsDollars(biggestLoss), color.white);
AddLabel(showLabels, "Long Profit: " +AsDollars(profitLong), if profitLong > 0 then color.green else if profitLong < 0 then color.red else color.gray);
AddLabel(showLabels, "Short Profit: " +AsDollars(profitShort), if profitShort > 0 then color.green else if profitShort < 0 then color.red else color.gray);
AddLabel(if !IsNan(CurrentPosition) and showLabels then 1 else 0, "Open: "+ (If isLong then "Bought" else "Sold") + " @ "+orderPrice, color.white);
AddLabel(if !IsNan(orderPrice) and showLabels then 1 else 0, "Open Trade P/L: "+ AsDollars(TradePL), if (TradePL > 0) then color.green else if (TradePl < 0) then color.red else color.gray);


#######################################
##  Chart Bubbles for Profit/Loss
#######################################

input showBubbles = yes;

AddChartBubble(showBubbles and isOrder and isLong[1], low, "$"+dollarProfitLoss, if dollarProfitLoss == 0 then Color.LIGHT_GRAY else if dollarProfitLoss > 0 then Color.GREEN else color.Red, 0);
AddChartBubble(showBubbles and isOrder and isShort[1], high,  "$"+dollarProfitLoss, if dollarProfitLoss == 0 then Color.LIGHT_GRAY else if dollarProfitLoss > 0 then Color.GREEN else color.Red, 1);



####
assignPriceColor(if bullphase then Color.GREEN else if bearphase then Color.RED else if (accphase or distphase or recphase or warnphase) then Color.ORANGE else Color.GRAY);